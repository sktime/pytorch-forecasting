from inspect import isclass

from skbase.testing import BaseFixtureGenerator as _BaseFixtureGenerator, QuickTester

from pytorch_forecasting._registry import all_objects

# whether to test only estimators from modules that are changed w.r.t. main
# default is False, can be set to True by pytest --only_changed_modules True flag
ONLY_CHANGED_MODULES = False


class BaseFixtureGenerator(_BaseFixtureGenerator, QuickTester):
    """Fixture generator for base testing functionality in sktime.

    Test classes inheriting from this and not overriding pytest_generate_tests
        will have estimator and scenario fixtures parametrized out of the box.

    Descendants can override:
        object_type_filter: str, class variable;
            Controls which objects are retrieved and tested:

            - If None, retrieves all objects.
            - If class, retrieves all classes inheriting from this class.
            - If str/list of str: retrieve objects with matching object_type tag.
            (e.g., "forecaster_pytorch_v1", "forecaster_pytorch_v2, "metric")
        fixture_sequence: list of str
            sequence of fixture variable names in conditional fixture generation
        _generate_[variable]: object methods, all (test_name: str, **kwargs) -> list
            generating list of fixtures for fixture variable with name [variable]
                to be used in test with name test_name
            can optionally use values for fixtures earlier in fixture_sequence,
                these must be input as kwargs in a call
        is_excluded: static method (test_name: str, est: class) -> bool
            whether test with name test_name should be excluded for object obj
            should be used only for encoding general rules, not individual skips
            individual skips should go on the EXCLUDED_TESTS list in _config
            requires _generate_object_class and _generate_object_instance as is
        _excluded_scenario: static method (test_name: str, scenario) -> bool
            whether scenario should be skipped in test with test_name test_name
            requires _generate_object_scenario as is.

    Fixtures parametrized
    ---------------------
    object_class: estimator inheriting from BaseObject
        ranges over estimator classes not excluded by EXCLUDE_ESTIMATORS, EXCLUDED_TESTS
    object_instance: instance of estimator inheriting from BaseObject
        ranges over estimator classes not excluded by EXCLUDE_ESTIMATORS, EXCLUDED_TESTS
        instances are generated by create_test_instance class method of object_class
    """

    # overrides object retrieval in scikit-base
    def _all_objects(self):
        """Retrieve list of all object classes of type self.object_type_filter.

        If self.object_type_filter is None, retrieve all objects.
        If class, retrieve all classes inheriting from self.object_type_filter.
        Otherwise (assumed str or list of str), retrieve all classes with tags
        object_type in self.object_type_filter.
        """
        filter = getattr(self, "object_type_filter", None)

        if isclass(filter):
            object_types = filter.get_class_tag("object_type", None)
        else:
            object_types = filter

        obj_list = all_objects(
            object_types=object_types,
            return_names=False,
            exclude_objects=self.exclude_objects,
        )

        if isclass(filter):
            obj_list = [obj for obj in obj_list if issubclass(obj, filter)]

        # run_test_for_class selects the estimators to run
        # based on whether they have changed, and whether they have all dependencies
        # internally, uses the ONLY_CHANGED_MODULES flag,
        # and checks the python env against python_dependencies tag
        # obj_list = [obj for obj in obj_list if run_test_for_class(obj)]

        return obj_list

    # which sequence the conditional fixtures are generated in
    fixture_sequence = [
        "object_pkg",
        "object_class",
        "object_instance",
    ]

    def _generate_object_pkg(self, test_name, **kwargs):
        """Return object package fixtures.

        Fixtures parametrized
        ---------------------
        object_pkg: object package inheriting from BaseObject
            ranges over all object packages not excluded by self.excluded_tests
        """
        object_classes_to_test = [
            obj for obj in self._all_objects() if not self.is_excluded(test_name, obj)
        ]
        object_names = [obj.name() for obj in object_classes_to_test]

        return object_classes_to_test, object_names

    def _generate_object_class(self, test_name, **kwargs):
        """Return object class fixtures.

        Fixtures parametrized
        ---------------------
        object_class: object inheriting from BaseObject
            ranges over all object classes not excluded by self.excluded_tests
        """

        if "object_pkg" in kwargs.keys():
            all_pkgs = [kwargs["object_pkg"]]
        else:
            # call _generate_object_pkg to get all the packages
            all_pkgs, _ = self._generate_object_pkg(test_name=test_name)

        all_cls = [obj.get_cls() for obj in all_pkgs]
        object_classes_to_test = [
            obj for obj in all_cls if not self.is_excluded(test_name, obj)
        ]
        object_names = [obj.__name__ for obj in object_classes_to_test]

        return object_classes_to_test, object_names
